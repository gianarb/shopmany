"use strict";
/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const api = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
const config_1 = require("./config");
const Span_1 = require("./Span");
const utility_1 = require("./utility");
/**
 * This class represents a basic tracer.
 */
class Tracer {
    /**
     * Constructs a new Tracer instance.
     */
    constructor(config = config_1.DEFAULT_CONFIG, _tracerProvider) {
        this._tracerProvider = _tracerProvider;
        const localConfig = utility_1.mergeConfig(config);
        this._defaultAttributes = localConfig.defaultAttributes;
        this._sampler = localConfig.sampler;
        this._traceParams = localConfig.traceParams;
        this.resource = _tracerProvider.resource;
        this.logger = config.logger || new core_1.ConsoleLogger(config.logLevel);
    }
    /**
     * Starts a new Span or returns the default NoopSpan based on the sampling
     * decision.
     */
    startSpan(name, options = {}, context = api.context.active()) {
        const parentContext = options.parent
            ? getContext(options.parent)
            : core_1.getParentSpanContext(context);
        // make sampling decision
        const samplingDecision = this._sampler.shouldSample(parentContext);
        const spanId = core_1.randomSpanId();
        let traceId;
        let traceState;
        if (!parentContext || !core_1.isValid(parentContext)) {
            // New root span.
            traceId = core_1.randomTraceId();
        }
        else {
            // New child span.
            traceId = parentContext.traceId;
            traceState = parentContext.traceState;
        }
        const traceFlags = samplingDecision
            ? api.TraceFlags.SAMPLED
            : api.TraceFlags.NONE;
        const spanContext = { traceId, spanId, traceFlags, traceState };
        if (!samplingDecision) {
            this.logger.debug('Sampling is off, starting no recording span');
            return new core_1.NoRecordingSpan(spanContext);
        }
        const span = new Span_1.Span(this, name, spanContext, options.kind || api.SpanKind.INTERNAL, parentContext ? parentContext.spanId : undefined, options.links || [], options.startTime);
        // Set default attributes
        span.setAttributes(Object.assign({}, this._defaultAttributes, options.attributes));
        return span;
    }
    /**
     * Returns the current Span from the current context.
     *
     * If there is no Span associated with the current context, undefined is returned.
     */
    getCurrentSpan() {
        const ctx = api.context.active();
        // Get the current Span from the context or null if none found.
        return core_1.getActiveSpan(ctx);
    }
    /**
     * Enters the context of code where the given Span is in the current context.
     */
    withSpan(span, fn) {
        // Set given span to context.
        return api.context.with(core_1.setActiveSpan(api.context.active(), span), fn);
    }
    /**
     * Bind a span (or the current one) to the target's context
     */
    bind(target, span) {
        return api.context.bind(target, span ? core_1.setActiveSpan(api.context.active(), span) : api.context.active());
    }
    /** Returns the active {@link TraceParams}. */
    getActiveTraceParams() {
        return this._traceParams;
    }
    getActiveSpanProcessor() {
        return this._tracerProvider.getActiveSpanProcessor();
    }
}
exports.Tracer = Tracer;
function getContext(span) {
    return isSpan(span) ? span.context() : span;
}
function isSpan(span) {
    return typeof span.context === 'function';
}
//# sourceMappingURL=Tracer.js.map