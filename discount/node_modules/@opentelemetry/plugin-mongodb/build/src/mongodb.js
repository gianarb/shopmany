"use strict";
/*!
 * Copyright 2019, OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// mongodb.Server type is deprecated so every use trigger a lint error
/* tslint:disable:deprecation */
const core_1 = require("@opentelemetry/core");
const api_1 = require("@opentelemetry/api");
const shimmer = require("shimmer");
const types_1 = require("./types");
const version_1 = require("./version");
/** MongoDBCore instrumentation plugin for OpenTelemetry */
class MongoDBPlugin extends core_1.BasePlugin {
    constructor(moduleName) {
        super('@opentelemetry/plugin-mongodb-core', version_1.VERSION);
        this.moduleName = moduleName;
        this._SERVER_METHODS = ['insert', 'update', 'remove', 'command'];
        this._CURSOR_METHODS = ['_next', 'next'];
        this._COMPONENT = 'mongodb';
        this._DB_TYPE = 'mongodb';
        this.supportedVersions = ['>=2 <4'];
    }
    /**
     * Patches MongoDB operations.
     */
    patch() {
        this._logger.debug('Patched MongoDB');
        if (this._moduleExports.Server) {
            for (const fn of this._SERVER_METHODS) {
                this._logger.debug(`patching mongodb.Server.prototype.${fn}`);
                shimmer.wrap(this._moduleExports.Server.prototype, 
                // Forced to ignore due to incomplete typings
                // tslint:disable-next-line:ban-ts-ignore
                // @ts-ignore
                fn, this._getPatchCommand(fn));
            }
        }
        if (this._moduleExports.Cursor) {
            this._logger.debug('patching mongodb.Cursor.prototype functions:', this._CURSOR_METHODS);
            shimmer.massWrap([this._moduleExports.Cursor.prototype], this._CURSOR_METHODS, 
            // tslint:disable-next-line:no-any
            this._getPatchCursor());
        }
        return this._moduleExports;
    }
    /** Unpatches all MongoDB patched functions. */
    unpatch() {
        shimmer.massUnwrap([this._moduleExports.Server.prototype], this._SERVER_METHODS);
        shimmer.massUnwrap([this._moduleExports.Cursor.prototype], this._CURSOR_METHODS);
    }
    /** Creates spans for Command operations */
    _getPatchCommand(operationName) {
        const plugin = this;
        return (original) => {
            return function patchedServerCommand(ns, commands, options, callback) {
                const currentSpan = plugin._tracer.getCurrentSpan();
                const resultHandler = typeof options === 'function' ? options : callback;
                if (!currentSpan ||
                    typeof resultHandler !== 'function' ||
                    typeof commands !== 'object') {
                    return original.apply(this, arguments);
                }
                const command = commands instanceof Array ? commands[0] : commands;
                const commandType = plugin._getCommandType(command);
                const type = commandType === types_1.MongodbCommandType.UNKNOWN
                    ? operationName
                    : commandType;
                const span = plugin._tracer.startSpan(`mongodb.${type}`, {
                    parent: currentSpan,
                    kind: api_1.SpanKind.CLIENT,
                });
                plugin._populateAttributes(span, ns, command, this);
                return original.call(this, ns, commands, plugin._patchEnd(span, resultHandler));
            };
        };
    }
    /**
     * Get the mongodb command type from the object.
     * @param command Internal mongodb command object
     */
    _getCommandType(command) {
        if (command.createIndexes !== undefined) {
            return types_1.MongodbCommandType.CREATE_INDEXES;
        }
        else if (command.findandmodify !== undefined) {
            return types_1.MongodbCommandType.FIND_AND_MODIFY;
        }
        else if (command.ismaster !== undefined) {
            return types_1.MongodbCommandType.IS_MASTER;
        }
        else if (command.count !== undefined) {
            return types_1.MongodbCommandType.COUNT;
        }
        else {
            return types_1.MongodbCommandType.UNKNOWN;
        }
    }
    /**
     * Populate span's attributes by fetching related metadata from the context
     * @param span span to add attributes to
     * @param ns mongodb namespace
     * @param command mongodb internal representation of a command
     * @param topology mongodb internal representation of the network topology
     */
    _populateAttributes(span, ns, command, topology) {
        var _a, _b, _c, _d, _e, _f;
        // add network attributes to determine the remote server
        if (topology && topology.s) {
            span.setAttributes({
                [types_1.AttributeNames.PEER_HOSTNAME]: `${_b = (_a = topology.s.options) === null || _a === void 0 ? void 0 : _a.host, (_b !== null && _b !== void 0 ? _b : topology.s.host)}`,
                [types_1.AttributeNames.PEER_PORT]: `${_d = (_c = topology.s.options) === null || _c === void 0 ? void 0 : _c.port, (_d !== null && _d !== void 0 ? _d : topology.s.port)}`,
            });
        }
        // add database related attributes
        span.setAttributes({
            [types_1.AttributeNames.DB_INSTANCE]: `${ns}`,
            [types_1.AttributeNames.DB_TYPE]: this._DB_TYPE,
            [types_1.AttributeNames.COMPONENT]: this._COMPONENT,
        });
        if (command === undefined)
            return;
        const query = Object.keys((_f = (_e = command.query, (_e !== null && _e !== void 0 ? _e : command.q)), (_f !== null && _f !== void 0 ? _f : command))).reduce((obj, key) => {
            obj[key] = '?';
            return obj;
        }, {});
        span.setAttribute('db.statement', JSON.stringify(query));
    }
    /** Creates spans for Cursor operations */
    _getPatchCursor() {
        const plugin = this;
        return (original) => {
            return function patchedCursorCommand(...args) {
                const currentSpan = plugin._tracer.getCurrentSpan();
                const resultHandler = args[0];
                if (!currentSpan || typeof resultHandler !== 'function') {
                    return original.apply(this, args);
                }
                const span = plugin._tracer.startSpan(`mongodb.query`, {
                    parent: currentSpan,
                    kind: api_1.SpanKind.CLIENT,
                });
                plugin._populateAttributes(span, this.ns, this.cmd, this.topology);
                return original.call(this, plugin._patchEnd(span, resultHandler));
            };
        };
    }
    /**
     * Ends a created span.
     * @param span The created span to end.
     * @param resultHandler A callback function.
     */
    _patchEnd(span, resultHandler) {
        return function patchedEnd(...args) {
            const error = args[0];
            if (error instanceof Error) {
                span.setStatus({
                    code: api_1.CanonicalCode.UNKNOWN,
                    message: error.message,
                });
            }
            else {
                span.setStatus({
                    code: api_1.CanonicalCode.OK,
                });
            }
            span.end();
            return resultHandler.apply(this, args);
        };
    }
}
exports.MongoDBPlugin = MongoDBPlugin;
exports.plugin = new MongoDBPlugin('mongodb');
//# sourceMappingURL=mongodb.js.map